#!/usr/bin/python

# Requires gnuplot
# Add a cron job to clean up /var/www/html/tmp/*.png

# -*- coding: UTF-8 -*-# enable debugging
import cgitb, cgi
cgitb.enable()
print("Content-Type: text/html;charset=utf-8\n")

import MySQLdb
db = MySQLdb.connect(host="localhost",
                     user="root",
                     passwd="nopass",
                     db="sgk_battconn_001")
cur = db.cursor()

from subprocess import call
from shutil import copy
from os import remove
from time import time
from random import randint

########################################################################################################################
# Function Definitions
########################################################################################################################

# Verify that 'table' is a valid name before using it in database queries.
def sanitize_table_name( table, cursor ):
	cursor.execute("SELECT table_name from overview")
	for row in cursor.fetchall():
		if( row[0] == table ):
			return row[0]
	return ""

# Returns the UNIX timestamp of the last datapoint in 'table'
def last_timestamp( table, cursor ):
	cursor.execute("SELECT MAX(unix_timestamp(timestamp)) AS timestamp FROM " + table)
	date = int(cursor.fetchall()[0][0])
	return date

# Returns the UNIX timestamp of the first datapoint in 'table'
def first_timestamp( table, cursor ):
        cursor.execute("SELECT MIN(unix_timestamp(timestamp)) AS timestamp FROM " + table)
        date = int(cursor.fetchall()[0][0])
        return date

# Saves all data from 'table' in a file and returns the full path to the file.
# Only datapoints with timestamps between 'start_time' and 'end_time' are selected.
def save_data_I_V( table, start_time, end_time, cursor ):
	cursor.execute("SELECT unix_timestamp(timestamp),voltage,current FROM " 
		+ table + " WHERE unix_timestamp(timestamp) > "
		+ str(start_time) + " AND unix_timestamp(timestamp) < "
		+ str(end_time) )
	filename = "/tmp/sgk_" + str(randint(1,100000)) + ".dat"
	data_file = open(filename, "wb")
	data_file.write("# Autogenerated for gnuplot by battery controller web interface.\n\n\n")
	data_file.write("# time \tvoltage \tcurrent\n")
	for row in cursor.fetchall() :
        	string = str(row[0]) + "\t" + str(row[1]) + "\t" + str(row[2]) + "\n"
	        data_file.write(string)
	data_file.close()
	return filename

# Saves all data from 'table' in a file and returns the full path to the file.
# Only datapoints with timestamps between 'start_time' and 'end_time' are selected.
# Saved results have new column "power" which is volt*amp.
def save_data_power( table, start_time, end_time, cursor ):
        cursor.execute("SELECT unix_timestamp(timestamp),discharge,voltage,current FROM "
                + table + " WHERE unix_timestamp(timestamp) > "
                + str(start_time) + " AND unix_timestamp(timestamp) < "
                + str(end_time) )
        filename = "/tmp/sgk_" + str(randint(1,100000)) + ".dat"
        data_file = open(filename, "wb")
        data_file.write("# Autogenerated for gnuplot by battery controller web interface.\n\n\n")
        data_file.write("# Time (s)\tCapacity (W*s)\n")

	l_timestamp = 0
	l_discharge = 0
	l_capacity = 0
	for row in cursor.fetchall() :
		# Discharge mode is just starting
		if( row[1] == 1 and l_discharge == 0 ):
			# Set flag indicating the current cycle was discharge
			l_discharge = 1
			# Set when this 'slice' of the discharge began
			l_timestamp = row[0]
			# Reset accumulated capacity to 0
			l_capacity = 0
		# Discharge mode continues
		if( row[1] == 1 and l_discharge == 1 ):
			# Adding the capacity in watt*seconds to l_capacity
			# (capacity) = (   end  -    start    ) * (      volts  *  amps  )
			l_capacity   = ( row[0] - l_timestamp ) * ( -1 * row[2] * row[3] ) + l_capacity
			# Set when the next slice of the discharges begins
			l_timestamp = row[0]
		# Discharge mode just ended
		if( row[1] == 0 and l_discharge == 1 ):
			# Set flag indicating the current cycle was discharge.
			l_discharge = 0
			# Write data from the last discharge cycle to file
			string = str(row[0]) + "\t" + str(l_capacity) + "\n"
			data_file.write(string)
        data_file.close()
        return filename

# Returns total number of discharges 
def discharge_count( table, cursor ):
	cursor.execute("SELECT discharge FROM " + table)
        l_discharge = 0
        cycle_count = 0
        for row in cursor.fetchall() :
                # Discharge mode is just starting
                if( row[0] == 1 and l_discharge == 0 ):
                        # Set flag indicating the current cycle was discharge
                        l_discharge = 1
			# Increase discharge cycle count by 1
			cycle_count += 1;
                # Discharge mode just ended
                if( row[0] == 0 and l_discharge == 1 ):
                        # Set flag indicating the current cycle was discharge.
                        l_discharge = 0
        return cycle_count


# Plots (and outputs relevant HTML) for data in 'table'.
# Plot is Total Cell Capacity on Discharge versus Time.
# Uses data from the latest 'hours', with exception for "ALLTIME"
def plot_capacity( hours, table, cursor ):
	plot_file = open("/tmp/sgk_webrender.plt", "wb")
        xstop = last_timestamp( table, cursor )
        if( hours == "ALLTIME" ):
                xstart = first_timestamp( table, cursor)
        else:   
                xstart = xstop - (hours*60*60)
	data_filename = save_data_power( table, xstart, xstop, cursor )
	rand = randint(1,100000)
	plot_file.write(
                "set output \"/tmp/sgk_webrender.png\"\n"
                "set term pngcairo size 1550,375 enhanced font 'Verdana,10'\n"
                "set xrange [" + str(xstart) + ":" + str(xstop) + "]\n"
                "set ytics nomirror\n"
                "#set grid x y\n"
                "set tics out\n"
                "set xlabel 'Time (s)'\n"
                "set ylabel 'Capacity (W*s)'\n"
                "plot \"" + data_filename + "\" using 1:2 notitle\n "
        )
	plot_file.close()
	
	call(["gnuplot", "/tmp/sgk_webrender.plt"])
        copy("/tmp/sgk_webrender.png", "/var/www/html/tmp/chart" + str(rand) + ".png")
	
        print("<h3>" + str(hours) + " Hours</h3>")
        print("<img src=\"/tmp/chart" + str(rand) + ".png\" /><br />")
	remove("/tmp/sgk_webrender.png")
        remove("/tmp/sgk_webrender.plt")
        remove(data_filename)


# Plots (and outputs relevant HTML) for data in 'table'. 
# Plot is Voltage & Current versus Time.
# Uses data from the latest 'hours', with exception for "ALLTIME"
def plot_hours( hours, table, cursor ):
	plot_file = open("/tmp/sgk_webrender.plt", "wb")
	xstop = last_timestamp( table, cursor )
	if( hours == "ALLTIME" ):
		xstart = first_timestamp( table, cursor)
	else: 
		xstart = xstop - (hours*60*60)
	data_filename = save_data_I_V( table, xstart, xstop, cursor )
	rand = randint(1,100000)
	plot_file.write(
		"set output \"/tmp/sgk_webrender.png\"\n"
		"set term pngcairo size 1550,375 enhanced font 'Verdana,10'\n"
		"set xrange [" + str(xstart) + ":" + str(xstop) + "]\n"
		"set ytics nomirror\n"
		"#set grid x y2\n"
		"set y2tics\n"
		"set tics out\n"
		"set xlabel 'Time (s)'\n"
		"set ylabel 'Voltage (V)'\n"
		"set y2label 'Current (A)'\n"
		"plot \"" + data_filename + "\" using 1:2 notitle axes x1y1, "
		"\"" + data_filename + "\" using 1:3 notitle axes x1y2\n"
	)
	plot_file.close()

	call(["gnuplot", "/tmp/sgk_webrender.plt"])
	copy("/tmp/sgk_webrender.png", "/var/www/html/tmp/chart" + str(rand) + ".png")

	print("<h3>" + str(hours) + " Hours</h3>")
	print("<img src=\"/tmp/chart" + str(rand) + ".png\" /><br />")
	remove("/tmp/sgk_webrender.png")
	remove("/tmp/sgk_webrender.plt")
	remove(data_filename)

# Prints HTML table of all notes for a given database table
def print_notes( table, cursor ):
	cursor.execute("SELECT id,unix_timestamp(timestamp),table_name,description FROM overview WHERE table_name=\"" + table + "\"")
	print("<h3>Notes</h3>")
	print("<style>\n table, th, td { border: 1px solid black; padding: 5px }\n </style>")
	print("<table border=\"1\">\n")
	print("<tr><th>id</th><th>timestamp</th><th>table_name</th><th>description</th></tr>")
	for row in cursor.fetchall() :
		print("<tr><td>" + str(row[0]) + "</td><td>" + str(row[1]) + "</td><td>" + row[2] + "</td><td>" + row[3] + "</td></tr>\n")
	print("</table>\n")
	
########################################################################################################################
# Main program
########################################################################################################################

# If no table was specified in the calling URL (?table=xxx), or the value failed validation, then set table=overview
arguments = cgi.FieldStorage()
if "table" not in arguments:
	table = "overview"
else:
	table = sanitize_table_name( arguments['table'].value, cur )
	if table == "":
		table = "overview"

# Now there are two modes. Either we want data from a specific table, or we want the list of all tables.
if( table != "overview" ):
	print("<h1>Table: " + table + "</h1>\n")
	print("<a href=\"index.py\">Home</a>\n")
	print("<h2>Discharge Count: " + str(discharge_count(table, cur)) + "</h2>")
	print("<h2>Capacity</h2>\n")
	plot_capacity( "ALLTIME", table, cur )
	print("<h2>Voltage & Current</h2>\n")
	plot_hours( 1, table, cur )
	plot_hours( 6, table, cur )
	plot_hours( 24, table, cur )
	plot_hours( 168, table, cur )
	plot_hours( "ALLTIME", table, cur )
	print_notes( table, cur )
else:
	print("<h1>Overview</h1>\n")
	cur.execute("SELECT id,unix_timestamp(timestamp),table_name,description FROM overview")
	print("<style>\n table, th, td { border: 1px solid black; padding: 5px }\n </style>\n")
        print("<table border=\"1\">\n")
        print("<tr><th>id</th><th>timestamp</th><th>table_name</th><th>description</th></tr>\n")
        for row in cur.fetchall() :
                print("<tr><td>" + str(row[0]) + "</td><td>" + str(row[1]) + "</td><td>" + "<a href=\"index.py?table=" + row[2] + "\">" + row[2] + "</a>" + "</td><td>" + row[3] + "</td></tr>\n")
        print("</table>\n")
